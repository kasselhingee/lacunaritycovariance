#' @title Balanced estimation of centred spatial covariance for stationary RACS
#' @export pclns  pclns.cvchat
#' @description 
#' Estimates the pair-correlation function of a stationary RACS. 
#' A variety of balanced, partially balanced and classical estimates are available.
#' @author{Kassel Liam Hingee}

#' @param xi An observation of the RACS of interest. It can be in \pkg{spatstat}'s \code{owin} or \code{im} format. If \code{xi} is in \code{im} format then it is assumed that the pixels will be valued 1 (for foreground), 0 (for background) and NA for unobserved.
#' If \code{xi} is in \code{owin} format take care to consider what exactly the observation window is (if none is supplied then it will be assumed that the observation window is the smallest rectangle enclosing \code{xi}).
#' @param obswin The observation window in \code{owin} format. If it isn't included and \code{xi} is an \code{owin} object then \code{obswin} is taken to be the smallest rectangle enclosing \code{xi}. If \code{xi} is a \code{im} object than \code{obswin} is all the non-NA pixels in \code{xi}.
#' @param setcov_boundarythresh Any vector \eqn{v} such that set covariance of the observation window
#'  is smaller than this threshold is given a covariance of NA to avoid instabilities caused by dividing by very small areas, 
#' @param phat The classical estimate of coverage probability,
#'  which is the observed area in \code{xi} divided by the total area of the observation window.
#'  See \code{coverageprob} for more information.
#' @param cvchat The classical estimate of covariance in \code{im} format. Typically created with \code{racscovariance}.
#' @param cpp1 Picka's coverage probability estimate in \code{im} format. Typically generated by \code{cppicka} - see help for \code{cppicka} for more information.
#' @param modifications A list of strings specifying desired modifications or functions to apply to cvchat, cpp1 and phat.
#'  modifications = "all" will select all inbuilt modifications. See details. 

#' @return A named imlist of \pkg{SpatStat} \code{im} objects containing the centred covariance estimates from the different modifications.
#'  
#' 


#' @keywords spatial nonparametric

#' @details 
#' Modifications available are: 
#' \itemize{
#' \item \code{none} Returns cvchat / (phat * phat)
#' \item symm Returns the estimated average of cvchat at -v and +v, divided by (phat * phat)
#' \item mattfeld The pair-correlation estimator from Mattfeldt's paper
#' \item pickaint Picka's intrinsic modification which modifies the coverage probability estimators
#' \item pickahajek Picka's Hajek-based modification which additively modifies the covariance estimate.
#' }

#' @examples
#' xi <- heather$coarse
#' obswin <- Frame(xi)
#' phat <- coverageprob(xi, obswin = Frame(xi))
#' cvchat <- racscovariance(xi, inclraw = FALSE)
#' cpp1 <- cppicka(xi, obswin = Frame(heather$coarse))
#' 
#' pclnsfrcvc <- pclns.cvchat(cvchat, cpp1, phat, modifications = "all")
#' pclnsdir <- pclns(as.im(xi, na.replace = 0), modifications = "all")
#' ###SHOULD TEST ON BOOLEAN MODEL###
pclns <- function(xi, obswin = NULL,
                  setcov_boundarythresh = NULL,
                  modifications = "all"){
  cvchat <- racscovariance(xi, obswin, setcov_boundarythresh = setcov_boundarythresh)
  cpp1 <- cppicka(xi, obswin, setcov_boundarythresh = setcov_boundarythresh)
  phat <- coverageprob(xi, obswin)
  
  pclns <- pclns.cvchat(cvchat, cpp1, phat, modifications = modifications) 
  
  return(pclns)
}

#' @describeIn pclns Applies multiple modifications simultaneously from a precomputed cvchat, cpp1 and phat
pclns.cvchat <- function(cvchat, cpp1 = NULL, phat = NULL, modifications = "all"){
  harmonised <- harmonise.im(cvchat = cvchat, cpp1 = cpp1)
  cvchat <- harmonised$cvchat
  cpp1 <- harmonised$cpp1
  fcns <- list(
         none = pcln_none,
         symm = pcln_symm,
         mattfeldt = pcln_mattfeldt,
         pickaint = pcln_picka_intr,
         pickahajek = pcln_picka_hajek
  )
  if ((modifications == "all")[[1]]) {modifications <- names(fcns)}
  fcnstouse <- fcns[names(fcns) %in% modifications]
  isfunction <- unlist(lapply(modifications, function(x) "function" %in% class(x)))
  modificationsnotused <- modifications[!( (modifications %in% names(fcns)) | isfunction)]
  
  fcnstouse <- c(fcnstouse, modifications[isfunction]) #add user specified modification
  
  if(length(modificationsnotused) > 0){stop(
    paste("The following modifications are not recognised as existing function names or as a function:", modificationsnotused))}
  pclns <- lapply(fcnstouse, function(x) do.call(x, args = list(cvchat = cvchat, cpp1 = cpp1, phat = phat)))
  return(as.imlist(pclns))
}


pcln_none <- function(cvchat, cpp1 = NULL, phat = NULL){
  return(cvchat / (phat^2)) 
}

pcln_symm <- function(cvchat, cpp1 = NULL, phat = NULL){
  return((cvchat + reflect.im(cvchat)) / (2 * phat^2)) 
}

pcln_mattfeldt <- function(cvchat, cpp1, phat = NULL){
  return(2 * cvchat /(cpp1 + reflect.im(cpp1)) )  
}

pcln_picka_intr <- function(cvchat, cpp1, phat = NULL){
  return(cvchat / (cpp1*reflect.im(cpp1))) 
}

pcln_picka_hajek <- function(cvchat, cpp1, phat){
  hajek <- phat * (cpp1 + reflect.im(cpp1) - 2 * phat )
  return((cvchat - hajek) / (phat^2))
}

