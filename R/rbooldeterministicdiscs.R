#' @title Simulation of Boolean Model of Deterministic Discs
#' @export rbdd  bddcoverageprob bddcovar.iso bdd.covar bdd.specdensAtOrigin bdd.specdens
#' @importFrom stats fft
#' 
#' @description Functions for simulating a Boolean model with grains that are discs of fixed constant radius (the abreviation bdd is short for Boolean model with Determinisitic Discs).
#' A Boolean model is a two stage model, first the locations of grains, the germs are randomly distributed according to a Poisson point process, then a random grain is placed on each germ independently.
#' A thorough introduction can be found in [3].
#' Also described in this help file are functions for calculating from model parameters the true coverage probability, covariance, and spectral density [1,2].
#' 
#' @param lambda Intensity of the germ process (which is a Poisson point process)
#' @param discr Radius of the discs
#' @param window The window to simulate in (an owin object)
#' @param seed Optional input (default in NULL). Is an integer passed to \code{\link{base}{set.seed}}. Used to reproduce patterns exactly.

#' @return 
#' Depends on the function used (see Functions section).

#' @section WARNING:
#' The returned object of \code{rbdd} is only the contents of Xi and thus could be much smaller than the window (e.g. when the simulated set is empty).
#' 
#' 
#' @examples 
#' #Boolean model with discs of radius 10.
#' #The intensity has been chosen such that the true coverage probability is very close to 0.5.
#' discr <- 10
#' w <- owin(xrange=c(0,100),c(0,100))
#' lambda <- 2.2064E-3
#' xi <- rbdd(lambda,discr,w)
#' plot(xi)
#' plot(w,add=TRUE)
#' 
#' #calculate theoretical values of the model
#' truecoverageprob <- bddcoverageprob(lambda,discr)
#' truecovariance <- bdd.covar(
#'                    c(-10,10),c(-10,10),c(0.2,0.2),lambda,discr)
#' thspecdens <- bdd.specdens(lambda,discr)
#' thspecdens_origin <- bdd.specdensAtOrigin(lambda,discr)
#' thspecdens[round(dim(thspecdens)[2]/2),round(dim(thspecdens)[1]/2)]

#' @references 
#' [1] Koch, K., Ohser, J. and Schladitz, K. (2003) Spectral Theory for Random Closed Sets and Estimating the Covariance via Frequency Space. Advances in Applied Probability, 35, 603-613.
#' 
#' [2] Bohm, S., Heinrich, L. and Schmidt, V. (2004) Kernel Estimation of the Spectral Density of Stationary Random Closed Sets. Australian and New Zealand Journal of Statistics, 46, 41-51.
#' 
#' [3] Chiu, S.N., Stoyan, D., Kendall, W.S. and Mecke, J. (2013) Stochastic Geometry and Its Applications, 3rd ed. Chichester, United Kingdom: John Wiley & Sons.
#' @keywords spatial datagen



#' @describeIn rbdd Returns an \code{owin} that is a set generated by simulating a deterministic disc Boolean
#'  model with specified intensity and disc radius.
#'  The window information is not contained in this object.
#'  If the simulated set is empy then an empty \code{owin} object is returned.
#' The point process of germs is generated using spatstat's \code{\link[spatstat]{rpoispp}}.
rbdd <- function(lambda, discr, window, seed = NULL){
  grainlib <- solist(disc(radius = discr))
  bufferdist <- 1.1 * discr

  if (!missing(seed)){set.seed(seed)}
  pp <- rpoispp(lambda = lambda, win = dilation(window, bufferdist), nsim = 1, drop = TRUE) #lambda from B\"{o}m (2002) - chosen to make coverage probability very close to 0.5
  if (pp$n == 0 ){return(complement.owin(window))}
  xibuffer <- placegrainsfromlib(pp, grainlib)
  xi <- intersect.owin(xibuffer, window)
  return(xi)
}

#' @describeIn rbdd Returns the true coverage probability given the intensity and disc radius.
bddcoverageprob  <- function(lambda, discr){
  return (1 - exp(-pi * discr ^ 2 * lambda))
}

#theoretical set covariance of a disc
# @param r is the radius to calculate set covariance (can be a vector)
# @param discr is the radius of disc
setcovdisc <- function(r, discr){
  setcovariance <- r*0
  rsubset <- r[r < 2 * discr]
  setcovariance[r < 2 * discr] <- 2 * discr ^ 2 * acos(rsubset / (2 * discr)) - (rsubset / 2) * sqrt(4 * discr ^ 2 - rsubset ^ 2)
  return(setcovariance)
}

#' @describeIn rbdd Returns the true covariance of points separated by a distance \code{r} given the intensity, \code{lambda} and disc radius \code{discr} of the model.
#' @param r is the radius to calculate covariance
# @param lambda is the intensity of the germ process (Poisson point process)
# @param discr is the radius of the discs.
bddcovar.iso <- function(r, lambda, discr){
  expectedsetcovariance <- setcovdisc(r, discr)
  p <- 1 - exp(-pi * discr ^ 2 * lambda)
  covariance <- 2 * p - 1 + (1 - p ) ^ 2 * exp(lambda * expectedsetcovariance)
  return(covariance)
}
# covariance as a function of vectors given in X, Y columns.
bddcovar.vec <- function(X, Y, lambda, discr){
  rlist <- sqrt(X ^ 2 + Y ^ 2)
  covar <- vector(length(rlist), mode = "numeric")
  for (i in 1:length(rlist)){
    covar[i] <- bddcovar.iso(rlist[i], lambda = lambda, discr = discr)
  }
  return(covar)
}

#' @describeIn rbdd Returns an image of the covariance as calculated from disc radius and intensity.
#' @param xrange range of x values for \code{bdd.covar}
#' @param yrange range of y values for \code{bdd.covar}
#' @param eps list of length 2 of the steps between samples points in x and y respectively for \code{bdd.covar}.
bdd.covar <- function(xrange, yrange, eps, lambda, discr){
  xpts <- seq(from = xrange[1], to = xrange[2], by = eps[1])
  ypts <- seq(from = yrange[1], to = yrange[2], by = eps[2])
  mat <- outer(xpts, ypts, FUN = "bddcovar.vec", lambda = lambda, discr = discr) #rows correspond to xstep - just a quirk of outer!
  mat <- t(mat) #now columns correspond to x vals.
  return(im(mat, xcol = xpts, yrow = ypts))
}

#' @describeIn rbdd  Computes the spectral density using the theoretical covariance and FFT
bdd.specdens <- function(lambda, discr){
  xpts <- 0:(20 * discr) / 4
  ypts <- 0:(20 * discr) / 4
  mat <- outer(xpts, ypts, FUN = "bddcovar.vec", lambda = lambda, discr = discr) #rows correspond to xstep - just a quirk of outer!
  #reflect out to all corners
  mat <- mat[, c( (ncol(mat)):2, 1:ncol(mat))]
  mat <- mat[c( (nrow(mat)):2, 1:nrow(mat)), ]
  #theoretical p value
  p <- 1 - exp(-pi * discr ^ 2 * lambda)

  M <- mat - p ^ 2
  nr <- nrow(M)
  nc <- ncol(M)
  #pad with lots of 0!
  thcovpad <- matrix(0, ncol = 8 * nc, nrow = 8 * nr)
  thcovpad[1:nr, 1:nc] <- M
  scalefactorx <- (xpts[2] - xpts[1])
  scalefactory <- (ypts[2] - ypts[1])
  specdens <- scalefactorx * scalefactory * fft(thcovpad)
  specdens <- abs(specdens)
  nr <- nrow(specdens) #can use these because specdens has same dimensions as start
  nc <- ncol(specdens)
  if (nr %% 2 == 0){
    specdens <- specdens[ ( (-nr / 2):(nr / 2)) %% (nr) + 1, ]
    yrow <- ( (-nr / 2):(nr / 2)) * 2 * pi / (scalefactory * nr)
  } else {
    specdens <- specdens[ ( ( -(nr - 1) / 2):( (nr - 1) / 2)) %% (nr) + 1, ]
    yrow <- ( ( -(nr - 1) / 2):( (nr - 1) / 2)) * 2 * pi / (scalefactory * nr)
  }
  if (nc %% 2 == 0){
    specdens <- specdens[, ( (-nc / 2):(nc / 2)) %% (nc) + 1]
    xcol <- ( (-nc / 2):(nc / 2)) * 2 * pi / (scalefactorx * nc)
  } else {
    specdens <- specdens[, ( ( -(nc - 1) / 2):(nc / 2)) %% (nc) + 1]
    xcol <- ( ( -(nc - 1) / 2):(nc / 2))  *  2 * pi / (scalefactorx * nc)
  }

  specdens <- im(specdens, xcol = xcol, yrow = yrow)
  return(specdens)
}

#' @describeIn rbdd Calculates spectral density at at the origin using the theoretical covariance.
#' It is the integral of the (covariance - (coverage probability)^2) over all space.
bdd.specdensAtOrigin <- function(lambda, discr){
  xpts <- 0:(80 * discr) / 20
  ypts <- 0:(80 * discr) / 20
  mat <- outer(xpts, ypts, FUN = "bddcovar.vec", lambda = lambda, discr = discr) #rows correspond to xstep - just a quirk of outer!
  #reflect out to all corners
  mat <- mat[, c( (ncol(mat)):2, 1:ncol(mat))]
  mat <- mat[c( (nrow(mat)):2, 1:nrow(mat)), ]
  #theoretical p value
  p <- 1 - exp(-pi * discr ^ 2 * lambda)

  M <- mat - p ^ 2
  scalefactorx <- (xpts[2] - xpts[1])
  scalefactory <- (ypts[2] - ypts[1])
  return(sum(M) * scalefactory * scalefactorx)
}
