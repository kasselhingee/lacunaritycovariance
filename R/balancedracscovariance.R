#' @title Balanced spatial covariance estimation, also known as `two-point probability', estimator for stationary RACS
#' @export balancedracscovariances balancedracscovariance.cvchat  balancedracscovariances.cvchat cvchats.convolves  byconv.cvchats
#' @description 
#' This function estimate the covariance of a stationary RACS. 
#' A variety of balanced, partially balanced and classical estimates are available.
#' @author{Kassel Liam Hingee}



#' @param xi An observation of the RACS of interest. It can be in \pkg{spatstat}'s \code{owin} or \code{im} format. If \code{xi} is in \code{im} format then it is assumed that the pixels will be valued 1 (for foreground), 0 (for background) and NA for unobserved.
#' If \code{xi} is in \code{owin} format take care to consider what exactly the observation window is (if none is supplied then it will be assumed that the observation window is the smallest rectangle enclosing \code{xi}).
#' @param obswin The observation window in \code{owin} format. If it isn't included and \code{xi} is an \code{owin} object then \code{obswin} is taken to be the smallest rectangle enclosing \code{xi}. If \code{xi} is a \code{im} object than \code{obswin} is all the non-NA pixels in \code{xi}.
#' @param setcov_boundarythresh Any vector \eqn{v} such that set covariance of the observation window
#'  is smaller than this threshold is given a covariance of NA to avoid instabilities caused by dividing by very small areas, 
#' @param phat The classical estimate of coverage probability,
#'  which is the observed area in \code{xi} divided by the total area of the observation window.
#'  See \code{coverageprob} for more information.
#' @param cvchat The classical estimate of covariance in \code{im} format. Typically created with \code{racscovariance}.
#' @param cpp1 Picka's coverage probability estimate in \code{im} format. Typically generated by \code{cppicka} - see help for \code{cppicka} for more information.
#' @param modification A string specifying the desired modification. See details.
#' @param modifications A list of strings specifying desired modifications or functions to apply to cvchat, cpp1 and phat.
#'  modifications = "all" will select all inbuilt modifications. See details. 
#' @param xixi The convolution of a set representing xi with itself
#' @param winwin The convolution of the observation window with itself
#' @param xiwin The convolution of the set xi with the observation window

#' @return \code{racscovariance.cvchat} returns a \pkg{SpatStat} \code{im} object containing the modified estimated covariance.
#'  The grey scale values in this image represent the covariance for an array of vectors. 
#'  \code{racscovariances.cvchat} is a named imlist of such image objects for each of the modifications requested.
#'  
#' 


#' @keywords spatial nonparametric

#' @details 
#' Modifies the classical covariance estimator to based on balancing ideas for pair-correlation and centred covariance estimation.
#' Many of the modifications use Picka's coverage probability estimators in some way.
#' Modifications available are: 
#' \itemize{
#' \item \code{none} Returns cvchat
#' \item symm Returns the estimated average of cvchat at -v and +v
#' \item adrian  Similar to Picka additive but uses \code{cpp1} twice and not the refelction of \code{cpp1}
#' \item mattfeldadd
#' \item mattfeldmult
#' \item pickaint The only modification supplied that provides estimates that satisfy C(v) = 2phat - 1 + Ccomplment(v)
#' \item pickaintmult
#' \item pickaH
#' }

#' @examples
#' xi <- heather$coarse
#' obswin <- Frame(xi)
#' balancedcvchats <- balancedracscovariances(xi, obswin = Frame(xi), modifications = "all")
#' balancedcvchats2 <- byconv.cvchats(xi, obswin = Frame(xi), modifications = "all")
#' 
#' plot.solist(c(balancedcvchats, balancedcvchats2), ncols = 8)
#' diff <- mapply(function(x, y) x - y, balancedcvchats, balancedcvchats2, SIMPLIFY = FALSE)
#' plot.solist(diff)
#' 
#' xixi <- setcov(xi, xy = xi)
#' winwin <- setcov(obswin, xy = xi)
#' xiwin <- setcov(xi, obswin, xy = xi)

#' phat <- coverageprob(xi, obswin = Frame(xi))
#' cvchat <- racscovariance(xi, inclraw = FALSE)
#' cpp1 <- cppicka(xi, obswin = Frame(heather$coarse))
#' harmonised <- harmonise.im(cvchat = cvchat, cpp1 = cpp1)
#' cvchat <- harmonised$cvchat
#' cpp1 <- harmonised$cpp1
#' 
#' balancedcvchat <- balancedracscovariance.cvchat(cvchat, cpp1, phat, modification = "pickaint")
#' balancedcvchats <- balancedracscovariances.cvchat(cvchat, cpp1, phat, modifications = "all")
#' modifications <- c("none",
#'  "symm",
#'  "adrian",
#'  "mattfeldt",
#'  "mattfeldtmult",
#'  "pickaint",
#'  "pickaintmult",
#'  "pickaH", 
#'  function(cvchat, cpp1, phat) cvchat)
#' balancedcvchats <- balancedracscovariances.cvchat(cvchat, cpp1, phat, modifications = modifications)
#' plot(as.solist(balancedcvchats), equal.ribbon = TRUE)
#' 

#' 
balancedracscovariances <- function(xi, obswin = NULL,
        setcov_boundarythresh = NULL,
        modifications = "all"){
  cvchat <- racscovariance(xi, obswin, setcov_boundarythresh = setcov_boundarythresh)
  cpp1 <- cppicka(xi, obswin, setcov_boundarythresh = setcov_boundarythresh)
  phat <- coverageprob(xi, obswin)
  
  cvchats <- balancedracscovariances.cvchat(cvchat, cpp1, phat, modifications = modifications) 
  return(cvchats)
}

byconv.cvchats <- function(xi, obswin,
        xy = NULL,
        setcov_boundarythresh = NULL,
        modifications = "all"){
  if (is.null(setcov_boundarythresh)){
    setcov_boundarythresh <- 0.1 * area.owin(obswin)
  }
  if (is.null(xy)){
    if(is.mask(xi)){
      xy <- xi
    }  else {
      stop("xy must be supplied")
    }
  }
  xixi <- setcov(xi, xy = xy)
  winwin <- setcov(obswin, xy = xy)
  winwin[winwin < setcov_boundarythresh] <- NA #to remove small denominators
  xiwin <- setcov(xi, obswin, xy = xy)
  xiwin[winwin < setcov_boundarythresh] <- NA #to remove small denominators
  phat <- area.owin(xi) / area.owin(obswin)
  
  cvchats <- cvchats.convolves(xixi, winwin, xiwin, phat, modifications = modifications) 
  return(cvchats)
}

#' @describeIn balancedracscovariances Applies covariance balancing modification to precomputed cvchat, cpp1 and phat
balancedracscovariance.cvchat <- function(cvchat, cpp1 = NULL, phat = NULL, modification = "pickaH"){
  harmonised <- harmonise.im(cvchat = cvchat, cpp1 = cpp1)
  cvchat <- harmonised$cvchat
  cpp1 <- harmonised$cpp1
  balancedcvchat <- switch(modification,
         none = cvchat,
         symm = balancedracscovariance_symm(cvchat),
         adrian = balancedracscovariance_adrian(cvchat, cpp1, phat),
         mattfeldt = balancedracscovariance_mattfeldt_add(cvchat, cpp1, phat),
         mattfeldtmult = balancedracscovariance_mattfeldt_mult(cvchat, cpp1, phat),
         pickaint = balancedracscovariance_picka_int(cvchat, cpp1, phat),
         pickaintmult = balancedracscovariance_picka_intmult(cvchat, cpp1, phat),
         pickaH = balancedracscovariance_picka_H(cvchat, cpp1, phat),
         stop(paste("Modification", modification, "not found.")) 
         )
  return(balancedcvchat)
}

#' @describeIn balancedracscovariances Applies multiple modifications simultaneously from a precomputed cvchat, cpp1 and phat
balancedracscovariances.cvchat <- function(cvchat, cpp1 = NULL, phat = NULL, modifications = "all"){
  harmonised <- harmonise.im(cvchat = cvchat, cpp1 = cpp1)
  cvchat <- harmonised$cvchat
  cpp1 <- harmonised$cpp1
  fcns <- list(
         none = function(cvchat, cpp1 = NULL, phat = NULL) cvchat,
         symm = balancedracscovariance_symm,
         adrian = balancedracscovariance_adrian,
         mattfeldt = balancedracscovariance_mattfeldt_add,
         mattfeldtmult = balancedracscovariance_mattfeldt_mult,
         pickaint = balancedracscovariance_picka_int,
         pickaintmult = balancedracscovariance_picka_intmult,
         pickaH = balancedracscovariance_picka_H
  )
  if ((modifications == "all")[[1]]) {modifications <- names(fcns)}
  fcnstouse <- fcns[names(fcns) %in% modifications]
  isfunction <- unlist(lapply(modifications, function(x) "function" %in% class(x)))
  modificationsnotused <- modifications[!( (modifications %in% names(fcns)) | isfunction)]
  
  fcnstouse <- c(fcnstouse, modifications[isfunction]) #add user specified modification
  
  if(length(modificationsnotused) > 0){stop(
    paste("The following modifications are not recognised as existing function names or as a function:", modificationsnotused))}
  balancedcvchats <- lapply(fcnstouse, function(x) do.call(x, args = list(cvchat = cvchat, cpp1 = cpp1, phat = phat)))
  return(as.imlist(balancedcvchats))
}

#' @describeIn balancedracscovariances Applies multiple modifications simultaneously from a precomputed convolutions xi*xi, w*w, xi*w and phat
cvchats.convolves <- function(xixi, winwin, xiwin = NULL, phat = NULL, modifications = "all"){
  harmonised <- harmonise.im(xixi = xixi, winwin = winwin, xiwin = xiwin)
  xixi <- harmonised$xixi
  winwin <- harmonised$winwin
  xiwin <- harmonised$xiwin
  fcns <- list(
         none = cvchat_none,
         symm = cvchat_symm,
         adrian = cvchat_adrian,
         mattfeldt = cvchat_mattfeldt_add,
         mattfeldtmult = cvchat_mattfeldt_mult,
         pickaint = cvchat_picka_int,
         pickaintmult = cvchat_picka_intmult,
         pickaH = cvchat_picka_H
  )
  if ((modifications == "all")[[1]]) {modifications <- names(fcns)}
  fcnstouse <- fcns[names(fcns) %in% modifications]
  isfunction <- unlist(lapply(modifications, function(x) "function" %in% class(x)))
  modificationsnotused <- modifications[!( (modifications %in% names(fcns)) | isfunction)]
  
  fcnstouse <- c(fcnstouse, modifications[isfunction]) #add user specified modification
  
  if(length(modificationsnotused) > 0){stop(
    paste("The following modifications are not recognised as existing function names or as a function:", modificationsnotused))}
  balancedcvchats <- lapply(fcnstouse, function(x) do.call(x, args = list(xixi = xixi, winwin = winwin, xiwin = xiwin, phat = phat)))
  return(as.imlist(balancedcvchats))
}

cvchat_none <- function(xixi, winwin, xiwin = NULL, phat = NULL){
  return(xixi / winwin)
}

balancedracscovariance_symm <- function(cvchat, cpp1 = NULL, phat = NULL){
  return((cvchat + reflect.im(cvchat))/2) 
}

cvchat_symm <- function(xixi, winwin, xiwin = NULL, phat = NULL){
  return((xixi + reflect.im(xixi))/ (2 * winwin))
}

balancedracscovariance_adrian <- function(cvchat, cpp1, phat){
  return(cvchat - cpp1*cpp1 + phat^2) 
}

cvchat_adrian <- function(xixi, winwin, xiwin = NULL, phat = NULL){
  return((xixi - (xiwin * xiwin / winwin)) / winwin + phat^2)
}


balancedracscovariance_mattfeldt_add <- function(cvchat, cpp1, phat){
  return(cvchat - ( (cpp1 + reflect.im(cpp1))/2 )^2 + phat^2) 
}

cvchat_mattfeldt_add <- function(xixi, winwin, xiwin = NULL, phat = NULL){
  return((xixi - (0.5 * (xiwin + reflect.im(xiwin)))^2 / winwin ) / winwin  +  phat^2)
}

balancedracscovariance_mattfeldt_mult <- function(cvchat, cpp1, phat){
  return(cvchat * phat^2/ ( ( (cpp1 + reflect.im(cpp1))/2 )^2) ) 
}

cvchat_mattfeldt_mult <- function(xixi, winwin, xiwin = NULL, phat = NULL){
  mattfeldtnum <- 0.5 * (xiwin + reflect.im(xiwin))
  return((xixi * phat ^2 * winwin) / (mattfeldtnum^2))
}

balancedracscovariance_picka_int <- function(cvchat, cpp1, phat){
  return(cvchat - cpp1*reflect.im(cpp1) + phat^2) 
}

cvchat_picka_int <- function(xixi, winwin, xiwin = NULL, phat = NULL){
  return((xixi - xiwin * reflect.im(xiwin) / winwin) / winwin + phat ^2 )
}

balancedracscovariance_picka_intmult <- function(cvchat, cpp1, phat){
  return(cvchat * phat^2 / (cpp1*reflect.im(cpp1))) 
}

cvchat_picka_intmult <- function(xixi, winwin, xiwin = NULL, phat = NULL){
  return((xixi * phat^2 * winwin) / (xiwin * reflect.im(xiwin)))
}

balancedracscovariance_picka_H <- function(cvchat, cpp1, phat){
  return(cvchat - phat*(cpp1 + reflect.im(cpp1) - 2*phat)) 
}

cvchat_picka_H <- function(xixi, winwin, xiwin, phat){
  return((xixi  - phat * xiwin - phat * reflect.im(xiwin)) / winwin  + 2* phat^2 )
}

