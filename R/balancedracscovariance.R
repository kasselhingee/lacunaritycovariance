#' @title Balanced spatial covariance estimation, also known as `two-point probability', estimator for stationary RACS
#' @export balancedracscovariances balancedracscovariance.cvchat  balancedracscovariances.cvchat
#' @description 
#' This function estimate the covariance of a stationary RACS. 
#' A variety of balanced, partially balanced and classical estimates are available.
#' @author{Kassel Liam Hingee}



#' @param xi An observation of the RACS of interest. It can be in \pkg{spatstat}'s \code{owin} or \code{im} format. If \code{xi} is in \code{im} format then it is assumed that the pixels will be valued 1 (for foreground), 0 (for background) and NA for unobserved.
#' If \code{xi} is in \code{owin} format take care to consider what exactly the observation window is (if none is supplied then it will be assumed that the observation window is the smallest rectangle enclosing \code{xi}).
#' @param obswin The observation window in \code{owin} format. If it isn't included and \code{xi} is an \code{owin} object then \code{obswin} is taken to be the smallest rectangle enclosing \code{xi}. If \code{xi} is a \code{im} object than \code{obswin} is all the non-NA pixels in \code{xi}.
#' @param setcov_boundarythresh Any vector \eqn{v} such that set covariance of the observation window
#'  is smaller than this threshold is given a covariance of NA to avoid instabilities caused by dividing by very small areas, 
#' @param phat The classical estimate of coverage probability,
#'  which is the observed area in \code{xi} divided by the total area of the observation window.
#'  See \code{coverageprob} for more information.
#' @param cvchat The classical estimate of covariance in \code{im} format. Typically created with \code{racscovariance}.
#' @param cpp1 Picka's coverage probability estimate in \code{im} format. Typically generated by \code{cppicka} - see help for \code{cppicka} for more information.
#' @param method A string specifying the desired method. See details.
#' @param methods A list of strings specifying desired methods or functions to apply to cvchat, cpp1 and phat.
#'  methods = "all" will select all inbuilt methods. See details. 

#' @return \code{racscovariance.cvchat} returns a \pkg{SpatStat} \code{im} object containing the modified estimated covariance.
#'  The grey scale values in this image represent the covariance for an array of vectors. 
#'  \code{racscovariances.cvchat} is a named imlist of such image objects for each of the methods requested.
#'  
#' 


#' @keywords spatial nonparametric

#' @details 
#' Modifies the classical covariance estimator to based on balancing ideas for pair-correlation and centred covariance estimation.
#' Many of the methods use Picka's coverage probability estimators in some way.
#' Methods available are: 
#' \itemize{
#' \item \code{none} Returns cvchat
#' \item symm Returns the estimated average of cvchat at -v and +v
#' \item adrian  Similar to Picka additive but uses \code{cpp1} twice and not the refelction of \code{cpp1}
#' \item mattfeldadd
#' \item mattfeldmult
#' \item pickaadd The only method supplied that provides estimates that satisfy C(v) = 2phat - 1 + Ccomplment(v)
#' \item pickamult
#' \item pickahajek
#' }

#' @examples
#' xi <- heather$coarse
#' obswin <- Frame(xi)
#' balancedcvchats <- balancedracscovariances(xi, obswin = Frame(xi), methods = "all")

#' phat <- coverageprob(xi, obswin = Frame(xi))
#' cvchat <- racscovariance(xi, inclraw = FALSE)
#' cpp1 <- cppicka(xi, obswin = Frame(heather$coarse))
#' harmonised <- harmonise.im(cvchat = cvchat, cpp1 = cpp1)
#' cvchat <- harmonised$cvchat
#' cpp1 <- harmonised$cpp1
#' 
#' balancedcvchat <- balancedracscovariance.cvchat(cvchat, cpp1, phat, method = "pickaadd")
#' balancedcvchats <- balancedracscovariances.cvchat(cvchat, cpp1, phat, methods = "all")
#' methods <- c("none",
#'  "symm",
#'  "adrian",
#'  "mattfeldtadd",
#'  "mattfeldtmult",
#'  "pickaadd",
#'  "pickamult",
#'  "pickahajek", 
#'  function(cvchat, cpp1, phat) cvchat)
#' balancedcvchats <- balancedracscovariances.cvchat(cvchat, cpp1, phat, methods = methods)
#' plot(as.solist(balancedcvchats), equal.ribbon = TRUE)
#' 

#' 
balancedracscovariances <- function(xi, obswin = NULL,
        setcov_boundarythresh = NULL,
        methods = NULL){
  cvchat <- racscovariance(xi, obswin, setcov_boundarythresh = setcov_boundarythresh)
  cpp1 <- cppicka(xi, obswin, setcov_boundarythresh = setcov_boundarythresh)
  phat <- coverageprob(xi, obswin)
  
  cvchats <- balancedracscovariances.cvchat(cvchat, cpp1, phat, methods = methods) 
  return(cvchats)
}

#' @describeIn balancedracscovariances Applies covariance balancing modification to precomputed cvchat, cpp1 and phat
balancedracscovariance.cvchat <- function(cvchat, cpp1 = NULL, phat = NULL, method = NULL){
  harmonised <- harmonise.im(cvchat = cvchat, cpp1 = cpp1)
  cvchat <- harmonised$cvchat
  cpp1 <- harmonised$cpp1
  balancedcvchat <- switch(method,
         none = cvchat,
         symm = balancedracscovariance_symm(cvchat),
         adrian = balancedracscovariance_adrian(cvchat, cpp1, phat),
         mattfeldtadd = balancedracscovariance_mattfeldt_add(cvchat, cpp1, phat),
         mattfeldtmult = balancedracscovariance_mattfeldt_mult(cvchat, cpp1, phat),
         pickaadd = balancedracscovariance_picka_add(cvchat, cpp1, phat),
         pickamult = balancedracscovariance_picka_mult(cvchat, cpp1, phat),
         pickahajek = balancedracscovariance_picka_hajek(cvchat, cpp1, phat),
         stop(paste("Method", method, "not found.")) 
         )
  return(balancedcvchat)
}

#' @describeIn balancedracscovariances Applies multiple methods simultaneously from a precomputed cvchat, cpp1 and phat
balancedracscovariances.cvchat <- function(cvchat, cpp1 = NULL, phat = NULL, methods = NULL){
  harmonised <- harmonise.im(cvchat = cvchat, cpp1 = cpp1)
  cvchat <- harmonised$cvchat
  cpp1 <- harmonised$cpp1
  fcns <- list(
         none = function(cvchat, cpp1 = NULL, phat = NULL) cvchat,
         symm = balancedracscovariance_symm,
         adrian = balancedracscovariance_adrian,
         mattfeldtadd = balancedracscovariance_mattfeldt_add,
         mattfeldtmult = balancedracscovariance_mattfeldt_mult,
         pickaadd = balancedracscovariance_picka_add,
         pickamult = balancedracscovariance_picka_mult,
         pickahajek = balancedracscovariance_picka_hajek
  )
  if (methods == "all") {methods <- names(fcns)}
  fcnstouse <- fcns[methods %in% names(fcns)]
  isfunction <- unlist(lapply(methods, function(x) "function" %in% class(x)))
  methodsnotused <- methods[!( (methods %in% names(fcns)) | isfunction)]
  
  fcnstouse <- c(fcnstouse, methods[isfunction]) #add user specified method
  
  if(length(methodsnotused) > 0){stop(
    paste("The following methods are not recognised as existing function names or as a function:", methodsnotused))}
  balancedcvchats <- lapply(fcnstouse, function(x) do.call(x, args = list(cvchat = cvchat, cpp1 = cpp1, phat = phat)))
  return(as.imlist(balancedcvchats))
}

balancedracscovariance_symm <- function(cvchat, cpp1 = NULL, phat = NULL){
  return((cvchat + reflect.im(cvchat))/2) 
}

balancedracscovariance_adrian <- function(cvchat, cpp1, phat){
  return(cvchat - cpp1*cpp1 + phat^2) 
}

balancedracscovariance_mattfeldt_add <- function(cvchat, cpp1, phat){
  return(cvchat - ( (cpp1 + reflect.im(cpp1))/2 )^2 + phat^2) 
}

balancedracscovariance_mattfeldt_mult <- function(cvchat, cpp1, phat){
  return(cvchat * phat^2/ ( ( (cpp1 + reflect.im(cpp1))/2 )^2) ) 
}

balancedracscovariance_picka_add <- function(cvchat, cpp1, phat){
  return(cvchat - cpp1*reflect.im(cpp1) + phat^2) 
}

balancedracscovariance_picka_mult <- function(cvchat, cpp1, phat){
  return(cvchat * phat^2 / (cpp1*reflect.im(cpp1))) 
}

balancedracscovariance_picka_hajek <- function(cvchat, cpp1, phat){
  return(cvchat - phat*(cpp1 + reflect.im(cpp1) - 2*phat)) 
}


