% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/placegrainsfromlib.R
\name{placegrainsfromlib}
\alias{placegrainsfromlib}
\alias{meangrainarea}
\alias{meangrainsetcov}
\alias{grainlib.covar}
\title{A function to help simulate Boolean models with user-provided grains}
\usage{
placegrainsfromlib(pp, grainlib, replace = TRUE, prob = NULL, w = NULL,
  xy = NULL)

meangrainarea(grainlib, weights = rep(1/length(grainlib), length(grainlib)))

meangrainsetcov(grainlib, weights = rep(1/length(grainlib), length(grainlib)),
  xy)

grainlib.covar(lambda, grainlib, weights, xy)
}
\arguments{
\item{pp}{A point pattern (in \code{ppp} format).}

\item{grainlib}{A list of grains (in \code{\link[spatstat]{solist}} format) that grains will be selected from}

\item{replace}{passed directly to \code{\link[base]{sample}}. When TRUE grains are chosen from library with replacement.}

\item{prob}{A list of probability weights for each grain in the library. Passed directly to \code{\link[base]{sample}}.
If NULL the grains are selected with equal probability.}

\item{w}{Optional desired observation window. If this is non-null then any grains with Frame outside the Frame of \code{w} will be ignored.
This reduces polygonal intersection calculations for very large buffer distances}

\item{xy}{An im or binary mask object that is used to specify the pixel array of objects.}

\item{weights}{Probability of selecting each grain in the library}

\item{lambda}{Intensity of germs of a Boolean model - for computing the covariance of a Boolean model that has grain distribution given by \code{grainlib} and \code{weights}.}
}
\value{
Returns an \code{owin} object.
}
\description{
A Boolean model has two components, a point process (called germs) and a process that creates
 independent identically distributed grains that are centred on the germs.
The point process of germs can be easily simulated using a variety of \code{spatstat} functions
 (note that this simulation window must include a buffer because grains centred outside an observation window can still be observed).
  The function here, \code{placegrainsfromlib},
  can then be used to randomly select grains from a library and place them around each point.
  The buffer zone must then be cropped out to get a simulation of the Boolean model in the desired observation window.
}
\details{
\code{placegrainsfromlib} randomly samples from a library of grains (\code{grainlib}) and places these on the points in \code{pp}.
}
\section{Functions}{
\itemize{
\item \code{meangrainarea}: Compute mean area of a random grain given by the library

\item \code{meangrainsetcov}: Compute the mean set covariance of the random grain given by the library.
xy is required because the set covariance function must rasterise the owin objects

\item \code{grainlib.covar}: Compute the covariance of a Boolean model with random grain given by the library
}}

\examples{
#Generate a germ-grain models where germs are a Poisson point process
# and grains are 2 or 3 different disc sizes.
grainlib <- solist(disc(radius = 1), disc(radius = 1.9), disc(radius = 0.2))
bufferdist <- 2 #chosen to be larger than the largest radius in library

w <- owin(xrange = c(0, 10), yrange = c(0, 10))

#simulate the germ process in an enlarged window
pp <- rpoispp(lambda = 0.1, win = dilation(w, bufferdist), nsim = 1, drop = TRUE)

plot(w)
xibuffer <- placegrainsfromlib(pp, grainlib)
plot(xibuffer, add = TRUE, lty = "dashed")

#get final simulation by intersection with desired window
xi <- intersect.owin(xibuffer, w)
plot(xi, hatch = TRUE, add = TRUE)

#demonstration that involves rasterisation.
xibuffer <- placegrainsfromlib(pp, grainlib, xy = as.mask(w, eps = 0.1))
plot(xibuffer)
plot(w, add = TRUE)

#Demo of covariance and set covariance computations: test on Boolean model
lambda <- 0.1
discr <- 10
weights <- c(0.9999, 0.0001)
grainlib <- solist(disc(r = discr), disc(r = 2*discr))
meangrainarea(grainlib, weights)
plot(meangrainsetcov(grainlib, weights, xy = as.mask(w, eps = 0.1)))
truecovartest <- grainlib.covar(lambda, grainlib, weights, xy = as.mask(w, eps = 0.1))
truecovariance <- bddcovar(
                   c(-10, 10), c(-10, 10), c(0.1, 0.1), lambda, discr)
plot(solist(truecovartest, truecovariance), clipwin = disc(r = 3))
plot(truecovartest - truecovariance, clipwin = disc(r = 3))
range(truecovartest - truecovariance)
}
\author{
Kassel Liam Hingee
}
\keyword{datagen}
\keyword{nonparametric}
\keyword{spatial}
