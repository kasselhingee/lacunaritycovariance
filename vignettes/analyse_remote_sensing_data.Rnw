\documentclass{article}

\newcommand{\code}[1]{{\tt #1}}

\begin{document}
\title{Estimating RACS Summary Functions from Remote Sensing Data}
\author{Kassel Hingee}

\maketitle

This document demonstrates how to estimate various RACS Summary Functions from data stored in a remote sensing raster data format.
The specific format used here is ERMapper raster format (extension .ers); other formats supported by gdal should work in a very similar fashion. 

\section{Installation of Support Packages}
It is necessary to install the following additional packages to read remote sensing data and convert it into the spatial formats used in \code{stationaryracsinference}:
\begin{itemize}
\item sp
\item rgdal
\item maptools
\item raster
\end{itemize}
 These can be installed by simply using \code{install.packages()} with the exception is rgdal. 
  rgdal requires first installation of GDAL (\verb!http://www.gdal.org/!) which is available for Windows, Mac and Linux. 
   On Windows I installed GDAL as part of the OSGeo4W package.
  Once GDAL is installed it is ok to run \code{install.packages("rgdal")}.

After installation load packages for use
<<loadpackages,echo=TRUE>>=
library("stationaryracsinference")
library("rgdal")
library("maptools")
library("raster")
@


\section{Demonstration Data}
The data demonstrating on is ...

Class of interested is 1.

\section{Set up the Observation Window}
Usually it is not desired (nor computationally feasible) to analyse the entire dataset.
 Here we specify the region of interest using a polygon in a saved shapefile.
 It is also possible to specify extents using coordinates (see help for \code{extent()} from the raster package).


<<readpolygon>>=
library("rgdal") #Reading shapefiles requires rgdal.
obspoly <- readOGR("../data","aregionofinterest")
#print the coordinate projection of the polygon data for sanity
crs(proj4string(obspoly)) 
@

Note the package \code{maptools} can also read shapefiles however it does not attach projection information to the object.

Since this region is non-rectangular a spatstat owin version will later be required for the estimations (most estimators will assume a rectangular boundary if one isn't supplied)

<<convertowinpoly,fig=TRUE>>=
library(maptools)
obsbdry <- as.owin(obspoly) #this is the only step that requires maptools
plot(obsbdry,main="A Region of Interest",axes=TRUE)
@

\section{Open raster data set and crop to region of interest}
The \code{raster} package is able to open and perform virtual operations on raster data.
The data is not actually loaded into memory (RAM) until it is converted into a \code{spatstat im} object.

<<openrasterdata,fig=TRUE>>=
#First unzip raster data (raster data was compressed in a zip to save space)
unzip("../data/demorsraster.zip")
xidataset <- raster("demorsraster.ers")
xidataset <- crop(xidataset,extent(obspoly))
plot(xidataset,main="Tree Canopy Map and Region of Interest")
plot(add=TRUE,obsbdry)
@
\code{xidataset} is currently a rectangular region containing obspoly, the data is still not in memory (RAM).

This is a binary image that is either NA or 1 where 1 is our class of interest (tree canopy).
If your data is not in this same form then additional transformations will be needed at this point.

To use \code{stationaryracsinference} functions the observation must be converted into a spatstat owin object.
This is a two step process that first requires conversion into \code{spatstat} image object and then conversion into an owin object.
<<conversiontoowin>>=
xiimage <- as.im(xidataset)
xiowin <- as.owin(xiimage)
@
Note that \code{as.owin()} assumes all NA values are outside the set, and everything else is inside the set.

\code{xiowin} currently has observations outside the polygon of interest.
Intersecting the two rectifies this.

<<intersectbdrywxiowin,fig=TRUE>>=
xiowin <- intersect.owin(xiowin,obsbdry)
plot(xiowin,main="Class cover in the region of interest",axes=TRUE)
@

\section{Estimation of RACS Summary Functions}

\end{document}